<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="BA2001_Error" xml:space="preserve">
    <value>'{0}' is a 64-bit image with a preferred base address below the 4GB boundary. Having a preferred base address below this boundary triggers a compatibility mode in Address Space Layout Randomization (ASLR) on recent versions of Windows that reduces the number of locations to which ASLR may relocate the binary. This reduces the effectiveness of ASLR at mitigating memory corruption vulnerabilities. To resolve this issue, either use the default preferred base address by removing any uses of /baseaddress from compiler command lines, or /BASE from linker command lines (recommended), or configure your program to start at a base address above 4GB when compiled for 64 bit platforms (by changing the constant passed to /baseaddress or /BASE). Note that if you choose to continue using a custom preferred base address, you will need to make this modification only for 64-bit builds, as base addresses above 4GB are not valid for 32-bit binaries.</value>
  </data>
  <data name="BA2001_LoadImageAboveFourGigabyteAddress_Description" xml:space="preserve">
    <value>64-bit images should have a preferred base address above the 4GB boundary to prevent triggering an Address Space Layout Randomization (ASLR) compatibility mode that decreases security. ASLR compatibility mode reduces the number of locations to which ASLR may relocate the binary, reducing its effectiveness at mitigating memory corruption vulnerabilities. To resolve this issue, either use the default preferred base address by removing any uses of /baseaddress from compiler command lines, or /BASE from linker command lines (recommended), or configure your program to start at a base address above 4GB when compiled for 64 bit platforms (by changing the constant passed to /baseaddress or /BASE). Note that if you choose to continue using a custom preferred base address, you will need to make this modification only for 64-bit builds, as base addresses above 4GB are not valid for 32-bit binaries.</value>
  </data>
  <data name="BA2001_Pass" xml:space="preserve">
    <value>'{0}' is a 64-bit image with a base address that is &gt;= 4 gigabytes, increasing the effectiveness of Address Space Layout Randomization (which helps prevent attackers from executing security-sensitive code in well-known locations).</value>
  </data>
  <data name="BA2002_DoNotIncorporateVulnerableBinaries_Description" xml:space="preserve">
    <value>Binaries should not take dependencies on code with known security vulnerabilities.</value>
  </data>
  <data name="BA2002_Error" xml:space="preserve">
    <value>'{0}' was built with a version of {1} which is subject to the following issues: {2}. To resolve this, {3}. The source files that triggered this were: {4}</value>
  </data>
  <data name="BA2002_Pass" xml:space="preserve">
    <value>'{0}' does not incorporate any known vulnerable dependencies, as configured by current policy.</value>
  </data>
  <data name="BA2005_DoNotShipVulnerableBinaries_Description" xml:space="preserve">
    <value>Do not ship obsolete libraries for which there are known security vulnerabilities.</value>
  </data>
  <data name="BA2005_Error" xml:space="preserve">
    <value>'{0}' appears to be an obsolete library (version {1}) for which there are known security vulnerabilities. To resolve this issue, obtain a version of {0} that is newer than version {2}. If this binary is not in fact {0}, ignore this warning.</value>
  </data>
  <data name="BA2005_Error_CouldNotParseVersion" xml:space="preserve">
    <value>Version information for '{0}' could not be parsed. The binary therefore could not be verified not to be an obsolete binary that is known to be vulnerable to one or more security problems.</value>
  </data>
  <data name="BA2005_MissingRequiredConfiguration" xml:space="preserve">
    <value>vulnerable binary name and version metadata</value>
  </data>
  <data name="BA2005_Pass" xml:space="preserve">
    <value>'{0}' is not known to be an obsolete binary that is vulnerable to one or more security problems.</value>
  </data>
  <data name="BA2006_BuildWithSecureTools_Description" xml:space="preserve">
    <value>Application code should be compiled with the most up-to-date tool sets possible to take advantage of the most current compile-time security features.</value>
  </data>
  <data name="BA2006_Error" xml:space="preserve">
    <value>'{0}' was compiled with one or more modules which were not built using minimum required tool versions (compiler version {1}). More recent toolchains contain mitigations that make it more difficult for an attacker to exploit vulnerabilities in programs they produce. To resolve this issue, compile and/or link your binary with more recent tools. If you are servicing a product where the tool chain cannot be modified (e.g. producing a hotfix for an already shipped version) ignore this warning. Modules built outside of policy: 
{2}</value>
  </data>
  <data name="BA2006_Error_BadModule" xml:space="preserve">
    <value>built with {0} compiler version {1} (Front end version {2})</value>
  </data>
  <data name="BA2006_Pass" xml:space="preserve">
    <value>All linked modules of '{0}' generated by the Microsoft front-end satisfy configured policy (compiler minimum version {1}).</value>
  </data>
  <data name="BA2007_EnableCriticalCompilerWarnings_Description" xml:space="preserve">
    <value>Binaries should be compiled with a warning level that enables all critical security-relevant checks. Enabling at least warning level 3 enables important static analysis in the compiler that can identify bugs with a potential to provoke memory corruption, information disclosure, or double-free vulnerabilities. To resolve this issue, compile at warning level 3 or higher by supplying /W3, /W4, or /Wall to the compiler, and resolve the warnings emitted.</value>
  </data>
  <data name="BA2007_Error_InsufficientWarningLevel" xml:space="preserve">
    <value>'{0}' was compiled at too low a warning level (effective warning level {1} for one or more modules). Warning level 3 enables important static analysis in the compiler to flag bugs that can lead to memory corruption, information disclosure, or double-free vulnerabilities. To resolve this issue, compile at warning level 3 or higher by supplying /W3, /W4, or /Wall to the compiler, and resolve the warnings emitted. An example compiler command line triggering this check: {2}
Modules triggering this check: {3}</value>
  </data>
  <data name="BA2007_Error_UnknownModuleLanguage" xml:space="preserve">
    <value>'{0}' contains code from an unknown language, preventing a comprehensive analysis of the compiler warning settings. The language could not be identified for the following modules: {1}</value>
  </data>
  <data name="BA2007_Error_WarningsDisabled" xml:space="preserve">
    <value>'{0}' disables compiler warning(s) which are required by policy. A compiler warning is typically required if it has a high likelihood of flagging memory corruption, information disclosure, or double-free vulnerabilities. To resolve this issue, enable the indicated warning(s) by removing /Wxxxx switches (where xxxx is a warning id indicated here) from your command line, and resolve any warnings subsequently raised during compilation. An example compiler command line triggering this check was: {1}
Modules triggering this check were:
{2}</value>
  </data>
  <data name="BA2007_Pass" xml:space="preserve">
    <value>'{0}' was compiled at a secure warning level ({1}) and does not include any modules that disable specific warnings that are required by policy. As a result, it is less likely that memory corruption, information disclosure, double-free and other security-related vulnerabilities exist in code.</value>
  </data>
  <data name="BA2008_EnableControlFlowGuard_Description" xml:space="preserve">
    <value>Binaries should enable the compiler control guard feature (CFG) at build time to prevent attackers from redirecting execution to unexpected, unsafe locations. CFG analyzes and discovers all indirect-call instructions at compilation and link time. It also injects a check that precedes every indirect call in code that ensures the target is an expected, safe location.  If that check fails at runtime, the operating system will close the program.</value>
  </data>
  <data name="BA2008_Error" xml:space="preserve">
    <value>'{0}' does not enable the control flow guard (CFG) mitigation. To resolve this issue, pass /GUARD:CF on both the compiler and linker command lines. Binaries also require the /DYNAMICBASE linker option in order to enable CFG.</value>
  </data>
  <data name="BA2008_MissingCompilerFlags" xml:space="preserve">
    <value>'{0}' contains one or more modules compiled without /GUARD:CF. {1}</value>
  </data>
  <data name="BA2008_NotApplicable_UnsupportedKernelModeVersion" xml:space="preserve">
    <value>'{0}' is a kernel mode portable executable compiled for a version of Windows that does not support the control flow guard feature for kernel mode binaries.</value>
  </data>
  <data name="BA2008_Pass" xml:space="preserve">
    <value>'{0}' enables the control flow guard mitigation. As a result, the operating system will force an application to close if an attacker is able to redirect execution in the component to an unexpected location.</value>
  </data>
  <data name="BA2009_EnableAddressSpaceLayoutRandomization_Description" xml:space="preserve">
    <value>Binaries should linked as DYNAMICBASE to be eligible for relocation by Address Space Layout Randomization (ASLR). ASLR is an important mitigation that makes it more difficult for an attacker to exploit memory corruption vulnerabilities. Configure your tools to build with this feature enabled. For C and C++ binaries, add /DYNAMICBASE to your linker command line. For .NET applications, use a compiler shipping with Visual Studio 2008 or later.</value>
  </data>
  <data name="BA2009_Error_NotDynamicBase" xml:space="preserve">
    <value>'{0}' is not marked as DYNAMICBASE. This means that the binary is not eligible for relocation by Address Space Layout Randomization (ASLR). ASLR is an important mitigation that makes it more difficult for an attacker to exploit memory corruption vulnerabilities. To resolve this issue, configure your tools to build with this feature enabled. For C and C++ binaries, add /DYNAMICBASE to your linker command line. For .NET applications, use a compiler shipping with Visual Studio 2008 or later.</value>
  </data>
  <data name="BA2009_Error_RelocsStripped" xml:space="preserve">
    <value>'{0}' is marked as DYNAMICBASE but relocation data has been stripped from the image, preventing address space layout randomization. </value>
  </data>
  <data name="BA2009_Error_WinCENoRelocationSection" xml:space="preserve">
    <value>'{0}' is a Windows CE image but does not contain any relocation data, preventing Address Space Layout Randomization.</value>
  </data>
  <data name="BA2009_Pass" xml:space="preserve">
    <value>'{0}' is properly compiled to enable Address Space Layout Randomization, reducing an attacker's ability to exploit code in well-known locations.</value>
  </data>
  <data name="BA2010_DoNotMarkImportsSectionAsExecutable_Description" xml:space="preserve">
    <value>PE sections should not be marked as both writable and executable. This condition makes it easier for an attacker to exploit memory corruption vulnerabilities, as it may provide an attacker executable location(s) to inject shellcode. Because the loader will always mark the imports section as writable, it is therefore important to mark this section as non-executable. To resolve this issue, ensure that your program does not mark the imports section executable. Look for uses of /SECTION or /MERGE on the linker command line, or #pragma segment in source code, which change the imports section to be executable, or which merge the ".rdata" segment into an executable section.</value>
  </data>
  <data name="BA2010_Error" xml:space="preserve">
    <value>'{0}' has the imports section marked executable. Because the loader will always mark the imports section as writable, it is important to mark this section as non-executable, so that an attacker cannot place shellcode here. To resolve this issue, ensure that your program does not mark the imports section as executable. Look for uses of /SECTION or /MERGE on the linker command line, or #pragma segment in source code, which change the imports section to be executable, or which merge the ".rdata" segment into an executable section.</value>
  </data>
  <data name="BA2010_Pass" xml:space="preserve">
    <value>'{0}' does not have an imports section that is marked as executable, helping to prevent the exploitation of code vulnerabilities.</value>
  </data>
  <data name="BA2011_EnableStackProtection_Description" xml:space="preserve">
    <value>Binaries should be built with the stack protector buffer security feature (/GS) enabled to increase the difficulty of exploiting stack buffer overflow memory corruption vulnerabilities. To resolve this issue, ensure that all modules compiled into the binary are compiled with the stack protector enabled by supplying /GS on the Visual C++ compiler command line.</value>
  </data>
  <data name="BA2011_Error" xml:space="preserve">
    <value>'{0}' is a C or C++ binary built with the stack protector buffer security feature disabled in one or more modules. The stack protector (/GS) is a security feature of the compiler which makes it more difficult to exploit stack buffer overflow memory corruption vulnerabilities. To resolve this issue, ensure that your code is compiled with the stack protector enabled by supplying /GS on the Visual C++ compiler command line. The affected modules were: {1}</value>
  </data>
  <data name="BA2011_Error_UnknownModuleLanguage" xml:space="preserve">
    <value>'{0}' contains code from an unknown language, preventing a comprehensive analysis of the stack protector buffer security features. The language could not be identified for the following modules: {1}.</value>
  </data>
  <data name="BA2011_Pass" xml:space="preserve">
    <value>'{0}' is a C or C++ binary built with the stack protector buffer security feature enabled for all modules, making it more difficult for an attacker to exploit stack buffer overflow memory corruption vulnerabilities. </value>
  </data>
  <data name="BA2012_DoNotModifyStackProtectionCookie_Description" xml:space="preserve">
    <value>Application code should not interfere with the stack protector. The stack protector (/GS) is a security feature of the compiler which makes it more difficult to exploit stack buffer overflow memory corruption vulnerabilities. The stack protector relies on a random number, called the "security cookie", to detect these buffer overflows. This 'cookie' is statically linked with your binary from a Visual C++ library in the form of the symbol __security_cookie. On recent Windows versions, the loader looks for the statically linked value of this cookie, and initializes the cookie with a far better source of entropy -- the system's secure random number generator -- rather than the limited random number generator available early in the C runtime startup code. When this symbol is not the default value, the additional entropy is not injected by the operating system, reducing the effectiveness of the stack protector. To resolve this issue, ensure that your code does not reference or create a symbol named __security_cookie or __security_cookie_complement.</value>
  </data>
  <data name="BA2012_Error" xml:space="preserve">
    <value>'{0}' is a C or C++ binary that interferes with the stack protector. The stack protector (/GS) is a security feature of the compiler which makes it more difficult to exploit stack buffer overflow memory corruption vulnerabilities. The stack protector relies on a random number, called the "security cookie", to detect these buffer overflows. This 'cookie' is statically linked with your binary from a Visual C++ library in the form of the symbol __security_cookie. On recent Windows versions, the loader looks for the magic statically linked value of this cookie, and initializes the cookie with a far better source of entropy -- the system's secure random number generator -- rather than the limited random number generator available early in the C runtime startup code. When this symbol is not the default value, the additional entropy is not injected by the operating system, reducing the effectiveness of the stack protector. To resolve this issue, ensure that your code does not reference or create a symbol named __security_cookie or __security_cookie_complement. NOTE: the modified cookie value detected was: {1}</value>
  </data>
  <data name="BA2012_Error_CouldNotLocateCookie" xml:space="preserve">
    <value>'{0}' is a C or C++binary that enables the stack protection feature but the security cookie could not be located. The binary may be corrupted.</value>
  </data>
  <data name="BA2012_Pass" xml:space="preserve">
    <value>'{0}' is a C or C++ binary built with the buffer security feature that properly preserves the stack protecter cookie. This has the effect of enabling a significant increase in entropy provided by the operating system over that produced by the C runtime start-up code.</value>
  </data>
  <data name="BA2012_Pass_NoLoadConfig" xml:space="preserve">
    <value>'{0}' is  C or C++binary that does not contain a load config table, which indicates either that it was compiled and linked with a version of the compiler that precedes stack protection features or is a binary (such as an ngen'ed assembly) that is not subject to relevant security issues.</value>
  </data>
  <data name="BA2012_Warning_InvalidSecurityCookieOffset" xml:space="preserve">
    <value>'{0}' appears to be a packed C or C++ binary that reports a security cookie offset that exceeds the size of the packed file. Use of the stack protector (/GS) feature therefore could not be verified. The file was possibly packed by: {1}.</value>
  </data>
  <data name="BA2012_Warning_InvalidSecurityCookieOffsetForPackedImage" xml:space="preserve">
    <value>'{0}' appears to be a packed C or C++ binary that reports a security cookie offset that exceeds the size of the packed file. Use of the stack protector (/GS) feature therefore could not be verified. The file was possibly packed by: {1}.</value>
  </data>
  <data name="BA2013_Error" xml:space="preserve">
    <value>'{0}' is a C or C++ binary that does not initialize the stack protector. The stack protector (/GS) is a security feature of the compiler which makes it more difficult to exploit stack buffer overflow memory corruption vulnerabilities. The stack protector requires access to entropy in order to be effective, which means a binary must initialize a random number generator at startup, by calling __security_init_cookie() as close to the binary's entry point as possible. Failing to do so will result in spurious buffer overflow detections on the part of the stack protector. To resolve this issue, use the default entry point provided by the C runtime, which will make this call for you, or call __security_init_cookie() manually in your custom entry point.</value>
  </data>
  <data name="BA2013_InitializeStackProtection_Description" xml:space="preserve">
    <value>Binaries should properly initialize the stack protector (/GS) in order to increase the difficulty of exploiting stack buffer overflow memory corruption vulnerabilities. The stack protector requires access to entropy in order to be effective, which means a binary must initialize a random number generator at startup, by calling __security_init_cookie() as close to the binary's entry point as possible. Failing to do so will result in spurious buffer overflow detections on the part of the stack protector. To resolve this issue, use the default entry point provided by the C runtime, which will make this call for you, or call __security_init_cookie() manually in your custom entry point.</value>
  </data>
  <data name="BA2013_NotApplicable_FeatureNotEnabled" xml:space="preserve">
    <value>'{0}' is a C or C++ binary that does not enable the stack protection buffer security feature. It is therefore not required to initialize the stack protector.</value>
  </data>
  <data name="BA2013_Pass" xml:space="preserve">
    <value>'{0}' is a C or C++ binary built with the buffer security feature that properly initializes the stack protecter. This has the effect of increasing the effectiveness of the feature and reducing spurious detections.</value>
  </data>
  <data name="BA2013_Pass_NoCode" xml:space="preserve">
    <value>'{0}' is a C or C++ binary that is not required to initialize the stack protection, as it does not contain executable code.</value>
  </data>
  <data name="BA2014_DoNotDisableStackProtectionForFunctions_Description" xml:space="preserve">
    <value>Application code should not disable stack protection for individual functions. The stack protector (/GS) is a security feature of the Windows native compiler which makes it more difficult to exploit stack buffer overflow memory corruption vulnerabilities. Disabling the stack protector, even on a function-by-function basis, can compromise the security of code. To resolve this issue, remove occurrences of __declspec(safebuffers) from your code. If the additional code inserted by the stack protector has been shown in profiling to cause a significant performance problem for your application, attempt to move stack buffer modifications out of the hot path of execution to allow the compiler to avoid inserting stack protector checks in these locations rather than disabling the stack protector altogether.</value>
  </data>
  <data name="BA2014_Error" xml:space="preserve">
    <value>'{0}' is a C or C++ binary built with function(s) ({1}) that disable the stack protector. The stack protector (/GS) is a security feature of the compiler which makes it more difficult to exploit stack buffer overflow memory corruption vulnerabilities. Disabling the stack protector, even on a function-by-function basis, is disallowed by SDL policy. To resolve this issue, remove occurrences of __declspec(safebuffers) from your code. If the additional code inserted by the stack protector has been shown in profiling to cause a significant performance problem for your application, attempt to move stack buffer modifications out of the hot path of execution to allow the compiler to avoid inserting stack protector checks in these locations rather than disabling the stack protector altogether.</value>
  </data>
  <data name="BA2014_Pass" xml:space="preserve">
    <value>'{0}' is a C or C++ binary built with the stack protector buffer security feature enabled which does not disable protection for any individual functions (via __declspec(safebuffers), making it more difficult for an attacker to exploit stack buffer overflow memory corruption vulnerabilities.</value>
  </data>
  <data name="BA2015_EnableHighEntropyVirtualAddresses_Description" xml:space="preserve">
    <value>Binaries should be marked as high entropy Address Space Layout Randomization (ASLR) compatible. High entropy allows ASLR to be more effective in mitigating memory corruption vulnerabilities. To resolve this issue, configure your tool chain to mark the program high entropy compatible; e.g. by supplying /HIGHENTROPYVA to the C or C++ linker command line. Binaries must also be compiled as /LARGEADDRESSAWARE in order to enable high entropy ASLR.</value>
  </data>
  <data name="BA2015_Error_NeitherHighEntropyVANorLargeAddressAware" xml:space="preserve">
    <value>'{0}' does not declare itself as high entropy ASLR compatible. High entropy makes Address Space Layout Randomization more effective in mitigating memory corruption vulnerabilities. To resolve this issue, configure your tools to mark the program high entropy compatible; e.g. by supplying /HIGHENTROPYVA as well as /LARGEADDRESSAWARE to the C or C++ linker command line.</value>
  </data>
  <data name="BA2015_Error_NoHighEntropyVA" xml:space="preserve">
    <value>'{0}' does not declare itself as high entropy ASLR compatible. High entropy makes Address Space Layout Randomization more effective in mitigating memory corruption vulnerabilities. To resolve this issue, configure your tools to mark the program high entropy compatible; e.g. by supplying /HIGHENTROPYVA to the C or C++ linker command line. (This image was determined to have been properly compiled as /LARGEADDRESSAWARE.)</value>
  </data>
  <data name="BA2015_Error_NoLargeAddressAware" xml:space="preserve">
    <value>'{0}' does not declare itself as high entropy ASLR compatible. High entropy makes Address Space Layout Randomization more effective in mitigating memory corruption vulnerabilities. To resolve this issue, configure your tools to mark the program high entropy compatible by supplying /LARGEADDRESSAWARE to the C or C++ linker command line. (This image was determined to have been properly compiled as /HIGHENTROPYVA.)</value>
  </data>
  <data name="BA2015_Pass" xml:space="preserve">
    <value>'{0}' is high entropy ASLR compatible, reducing an attacker's ability to exploit code in well-known locations.</value>
  </data>
  <data name="BA2016_Error" xml:space="preserve">
    <value>'{0}' is not marked NX compatible. The NXCompat bit, also known as "Data Execution Prevention" (DEP) or "Execute Disable" (XD), is a processor feature that allows a program to mark a piece of memory as non-executable. This helps mitigate memory corruption vulnerabilities by preventing an attacker from supplying direct shellcode in their exploit, because the exploit comes in the form of input data to the exploited program on a data segment, rather than on an executable code segment. To resolve this issue, ensure that your tools are configured to mark your binaries as NX compatible, e.g. by passing /NXCOMPAT to the C/C++ linker.</value>
  </data>
  <data name="BA2016_MarkImageAsNXCompatible_Description" xml:space="preserve">
    <value>Binaries should be marked as NX compatible to help prevent execution of untrusted data as code. The NXCompat bit, also known as "Data Execution Prevention" (DEP) or "Execute Disable" (XD), triggers a processor security feature that allows a program to mark a piece of memory as non-executable. This helps mitigate memory corruption vulnerabilities by preventing an attacker from supplying direct shellcode in their exploit (because the exploit comes in the form of input data to the exploited program on a data segment, rather than on an executable code segment). Ensure that your tools are configured to mark your binaries as NX compatible, e.g. by passing /NXCOMPAT to the C/C++ linker.</value>
  </data>
  <data name="BA2016_Pass" xml:space="preserve">
    <value>'{0}' is marked as NX compatible, helping to prevent attackers from executing code that is injected into data segments.</value>
  </data>
  <data name="BA2018_EnableSafeSEH_Description" xml:space="preserve">
    <value>X86 binaries should enable the SafeSEH mitigation to minimize exploitable memory corruption issues. SafeSEH makes it more difficult to exploit vulnerabilities that permit overwriting SEH control blocks on the stack, by verifying that the location to which a thrown SEH exception would jump is indeed defined as an exception handler in the source program (and not shellcode). To resolve this issue, supply the /SafeSEH flag on the linker command line. Note that you will need to configure your build system to supply this flag for x86 builds only, as the /SafeSEH flag is invalid when linking for ARM and x64.</value>
  </data>
  <data name="BA2018_Error" xml:space="preserve">
    <value>'{0}' is an x86 binary which {1}, indicating that it does not enable the SafeSEH mitigation. SafeSEH makes it more difficult to exploit memory corruption vulnerabilities that can overwrite SEH control blocks on the stack, by verifying that the location to which a thrown SEH exception would jump is indeed defined as an exception handler in the source program (and not shellcode). To resolve this issue, supply the /SafeSEH flag on the linker command line. Note that you will need to configure your build system to supply this flag for x86 builds only, as the /SafeSEH flag is invalid when linking for ARM and x64.</value>
  </data>
  <data name="BA2018_Error_EmptySEHandlerTable" xml:space="preserve">
    <value>has an empty SE handler table in the load configuration table</value>
  </data>
  <data name="BA2018_Error_LoadConfigurationIsTooSmall" xml:space="preserve">
    <value>contains an unexpectedly small load configuration table {size 0}</value>
  </data>
  <data name="BA2018_Error_NoLoadConfigurationTable" xml:space="preserve">
    <value>does not contain a load configuration table</value>
  </data>
  <data name="BA2018_Error_NoSEHandlers" xml:space="preserve">
    <value>has zero SE handlers in the load configuration table</value>
  </data>
  <data name="BA2018_Pass" xml:space="preserve">
    <value>'{0}' is an x86 binary that enables SafeSEH, a mitigation that verifies SEH exception jump targets are defined as exception handlers in the program (and not shellcode).</value>
  </data>
  <data name="BA2018_Pass_NoSEH" xml:space="preserve">
    <value>'{0}' is an x86 binary that does not use SEH, making it an invalid target for exploits that attempt to replace SEH jump targets with attacker-controlled shellcode.</value>
  </data>
  <data name="BA2019_DoNotMarkWritableSectionsAsShared_Description" xml:space="preserve">
    <value>Code or data sections should not be marked as both shared and writable. Because these sections are shared across processes, this condition might permit a process with low privilege to alter memory in a higher privilege process. If you do not actually require that a section be both writable and shared, remove one or both of these attributes (by modifying your .DEF file, the appropriate linker /section switch arguments, etc.). If you must share common data across processes (for inter-process communication (IPC) or other purposes) use CreateFileMapping with proper security attributes or an actual IPC mechanism instead (COM, named pipes, LPC, etc.).</value>
  </data>
  <data name="BA2019_Error" xml:space="preserve">
    <value>'{0}' contains one or more code or data sections ({1}) which are marked as both shared and writable. Because these sections are shared across processes, this condition might permit a process with low privilege to alter memory in a higher privilege process. If you do not actually require that a section be both writable and shared, remove one or both of these attributes (by modifying your .DEF file, the appropriate linker /section switch arguments, etc.). If you must share common data across processes (for inter-process communication (IPC) or other purposes) use CreateFileMapping with proper security attributes or an actual IPC mechanism instead (COM, named pipes, LPC, etc.).</value>
  </data>
  <data name="BA2019_Pass" xml:space="preserve">
    <value>'{0}' contains no data or code sections marked as both shared and writable, helping to prevent the exploitation of code vulnerabilities.</value>
  </data>
  <data name="BA2021_DoNotMarkWritableSectionsAsExecutable_Description" xml:space="preserve">
    <value>PE sections should not be marked as both writable and executable. This condition makes it easier for an attacker to exploit memory corruption vulnerabilities, as it may provide an attacker executable location(s) to inject shellcode. To resolve this issue, configure your tools to not emit memory sections that are writable and executable. For example, look for uses of /SECTION on the linker command line for C and C++ programs, or #pragma section in C and C++ source code, which mark a section with both attributes. Be sure to disable incremental linking in release builds, as this feature creates a writable and executable section named '.textbss' in order to function.</value>
  </data>
  <data name="BA2021_Error" xml:space="preserve">
    <value>'{0}' contains PE section(s) ({1}) that are both writable and executable. Writable and executable memory segments make it easier for an attacker to exploit memory corruption vulnerabilities, because it may provide an attacker executable location(s) to inject shellcode. To resolve this issue, configure your tools to not emit memory sections that are writable and executable. For example, look for uses of /SECTION on the linker command line for C and C++ programs, or #pragma section in C and C++ source code, which mark a section with both attributes. Enabling incremental linking via the /INCREMENTAL argument (the default for Microsoft Visual Studio debug build) can also result in a writable and executable section named 'textbss'. For this case, disable incremental linking (or analyze an alternate build configuration that disables this feature) to resolve the problem.</value>
  </data>
  <data name="BA2021_Error_UnexpectedSectionAligment" xml:space="preserve">
    <value>'{0}' has a section alignment ({1}) that is smaller than page size ({2}).</value>
  </data>
  <data name="BA2021_Pass" xml:space="preserve">
    <value>'{0}' contains no data or code sections marked as both shared and executable, helping to prevent the exploitation of code vulnerabilities.</value>
  </data>
  <data name="BA2022_Error_BadSigningAlgorithm" xml:space="preserve">
    <value>'{0}' was signed exclusively with algorithms that WinTrustVerify has flagged as insecure. {1}</value>
  </data>
  <data name="BA2022_Error_DidNotVerify" xml:space="preserve">
    <value>'{0}' signing was flagged as insecure by WinTrustVerify with error code '{1}' ({2})</value>
  </data>
  <data name="BA2022_Error_WinTrustVerifyApiError" xml:space="preserve">
    <value>'{0}' signing could not be completely verified because '{1}' failed with error code: '{2}'.</value>
  </data>
  <data name="BA2022_Pass" xml:space="preserve">
    <value>'{0}' appears to be signed securely by a trusted publisher with no verification or time stamp errors. Revocation checking was performed on the entire certificate chain, excluding the root certificate. The following digitial signature algorithms were detected: {1}</value>
  </data>
  <data name="BA2022_SignCorrectly_Description" xml:space="preserve">
    <value>Images should be correctly signed by trusted publishers using cryptographically secure signature algorithms. This rule invokes WinTrustVerify to validate that binary hash, signing and public key algorithms are secure and, where configurable, that key sizes meet acceptable size thresholds.</value>
  </data>
  <data name="NotApplicable_InvalidMetadata" xml:space="preserve">
    <value>'{0}' was not evaluated for check '{1}' as the analysis is not relevant based on observed metadata: {2}.</value>
  </data>
</root>